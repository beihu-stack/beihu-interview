##### 读写分离

> 1. 分摊主库压力
> 2. 写库可无索引，从库建索引
> 3. 核心业务不能从从节点读，会出现数据不一致的情况，数据同步到从节点需要时间



##### RabbitMQ的压力评估

​    事务机制



##### Kafka无事务机制？会丢消息？



##### 分布式与分布式集群的区别？



##### List的实现有？各自的特点？



##### Map的实现有？各种的特点？



##### Redis锁在集群情况下的问题？

​    如何保证多主的Redis能够同步到分布式锁？

​        循环设置

​        性能低，考虑使用ZK、EDCT做分布式锁



##### Jvm内存模型？

​    方法区、堆、虚拟机栈、程序计数器、本地方法栈(native)

​    

##### Java对象头信息？



##### Cloud原理？

​    挂载？卸载？寻址？原理



##### Synchronized实现原理？什么时候触发锁的升级？

> 底层是一系列指令标记
>
> 分为无锁、偏向锁（不断偏向新的线程，无cas）、轻量级锁、重量级锁
>
>  锁的升级逻辑：
>
> - 无锁到偏向锁：默认无锁 -> 线程1请求 -> cas获取偏向该线程的锁 -> 线程1再次请求，直接获取该锁 -> 线程1释放锁 -> Java对象头重新变成无锁状态
>
> - 偏向锁到轻量级锁：线程1持有该偏向锁时 -> 线程2来竞争该偏向锁 ->  撤销偏向锁（1. 已获得偏向锁的线程已经走完同步，标记变成无锁状态；2. 已获得偏向锁的线程还没执行完成，这时会将原先获得的偏向锁升级为轻量锁，在继续执行同步代码块）->升级偏向锁为轻量级锁（这个 操作需要等到全局安全点，也就是没有线程在执行字 节码）： **jvm 参数 UseBiasedLocking 来设置开启或关闭偏向锁**
> -  轻量级锁：
>   - 自旋锁：**默认情况下自旋的次数是 10 次， 可以通过 preBlockSpin 来修改**
>   - 自适应自旋锁：不固定，由上一次自旋时间和锁拥有者的状态来决定
>   - 到达一定上限，将不会再自旋，直接阻塞线程，避免cpu浪费资源
>
> - 重量级锁：线程只能通过唤醒和阻塞来获取同步资源



##### 线程池？线程池的拒绝策略？

> corePoolSize -> wrokQueue -> maxPoolSize -> RejectedExecutionHandler
>
> 拒绝策略：
>
> - AbortPolicy : 直接抛异常
>
> - DiscardPolicy：添加失败，忽略该任务，不抛异常
>
> - DiscardOldestPolicy：添加失败，将线程池队列中最早添加的任务移除，再重新添加新任务
>
> - CallerRunsPolicy：添加失败，主线程会自己去调executor的方法来执行该任务
>
> - 自定义：自己实现RejectedExecutionHandler，将自己的逻辑写到rejectedExecution方法中



##### Spring的原理？

​    参考我的开源项目



##### Mybatis的原理?

​    参考我的开源项目



##### 如何设计一个分页查询？

​    Skip + limit

​    优化: 添加查询位置标示（打标记或以id为标准、或以某个字段为排序规则）



##### Java中锁的原理？

​    AQS



##### Spring是如果解决循环依赖的？哪些情况是无法解决的？

> 构造参数依赖循环：无法处理，Spring将抛异常
>
> setter依赖、属性依赖：
>
> - 单例类，Spring可正常注入，因为属性依赖是后加载的
> - 原型类，无法处理，Spring将抛异常，因为Spring并没有维护原型类的缓存

​                            

##### 数据库对比：SQLServer、Oracle、MySQL、OceanBase